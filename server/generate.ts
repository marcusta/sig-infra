#!/usr/bin/env bun
/**
 * Caddyfile Generator
 *
 * Two-file architecture:
 * - services.json: Service structure (port, stripPath) - tracked in git
 * - services-state.json: Operational state (live/maintenance) - server-only
 *
 * Usage:
 *   bun generate.ts                    # Generate and reload
 *   bun generate.ts --dry-run          # Preview without writing
 *   bun generate.ts maint <service>    # Toggle maintenance mode
 *   bun generate.ts add <service> <port>  # Add new service
 *   bun generate.ts remove <service>   # Remove service
 *   bun generate.ts list               # List all services
 */

import { $ } from "bun";

const SCRIPT_DIR = import.meta.dir;
const SERVICES_STRUCTURE_FILE = `${SCRIPT_DIR}/services.json`;
const SERVICES_STATE_FILE = `${SCRIPT_DIR}/services-state.json`;
const CADDYFILE_PATH = "/srv/caddy/config/Caddyfile";
const TEMP_FILE = "/tmp/Caddyfile.new";
const DOMAIN = "app.swedenindoorgolf.se";
const MAINTENANCE_ROOT = "/maintenance";

// Structure: port, stripPath (tracked in git)
interface ServiceStructure {
  port: number;
  stripPath?: boolean; // default true (handle_path), false = handle (keep path)
  description?: string;
}

// State: live/maintenance (server-only)
interface ServiceState {
  live: boolean;
}

// Combined for Caddyfile generation
interface ServiceConfig extends ServiceStructure {
  live: boolean;
}

type ServicesStructure = Record<string, ServiceStructure>;
type ServicesState = Record<string, ServiceState>;
type Services = Record<string, ServiceConfig>;

async function loadServicesStructure(): Promise<ServicesStructure> {
  const file = Bun.file(SERVICES_STRUCTURE_FILE);
  if (!(await file.exists())) {
    console.error(`‚ùå ${SERVICES_STRUCTURE_FILE} not found. Create it first.`);
    process.exit(1);
  }
  return file.json();
}

async function loadServicesState(): Promise<ServicesState> {
  const file = Bun.file(SERVICES_STATE_FILE);
  if (!(await file.exists())) {
    // If state file doesn't exist, return empty object (will default to live: true)
    return {};
  }
  return file.json();
}

async function loadServices(): Promise<Services> {
  const structure = await loadServicesStructure();
  const state = await loadServicesState();

  // Merge: structure + state, defaulting to live: true
  const merged: Services = {};
  for (const [name, config] of Object.entries(structure)) {
    merged[name] = {
      ...config,
      live: state[name]?.live ?? true, // Default to live if not in state file
    };
  }

  return merged;
}

async function saveServicesStructure(services: ServicesStructure): Promise<void> {
  const content = JSON.stringify(services, null, 2) + "\n";
  const tempFile = "/tmp/services.json.new";
  await Bun.write(tempFile, content);
  await $`cat ${tempFile} | sudo tee ${SERVICES_STRUCTURE_FILE} > /dev/null`;
  await $`rm ${tempFile}`;
}

async function saveServicesState(state: ServicesState): Promise<void> {
  const content = JSON.stringify(state, null, 2) + "\n";
  const tempFile = "/tmp/services-state.json.new";
  await Bun.write(tempFile, content);
  await $`cat ${tempFile} | sudo tee ${SERVICES_STATE_FILE} > /dev/null`;
  await $`rm ${tempFile}`;
}

function generateServiceBlock(path: string, config: ServiceConfig): string {
  const stripPath = config.stripPath !== false; // default true
  
  if (config.live) {
    if (stripPath) {
      return `    handle_path /${path}/* {
        reverse_proxy localhost:${config.port}
    }`;
    } else {
      return `    handle /${path}* {
        reverse_proxy localhost:${config.port}
    }`;
    }
  } else {
    // Maintenance mode - always use handle (broader match)
    return `    handle /${path}* {
        # live_port:${config.port}
        # strip_path:${stripPath}
        root * ${MAINTENANCE_ROOT}
        rewrite * /index.html
        file_server
    }`;
  }
}

function generateCaddyfile(services: Services): string {
  const serviceBlocks = Object.entries(services)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([name, config]) => generateServiceBlock(name, config))
    .join("\n\n");

  return `# Auto-generated by generate.ts ‚Äî DO NOT EDIT MANUALLY
# Source of truth: ${SERVICES_FILE}
# Generated: ${new Date().toISOString()}

${DOMAIN} {
    log {
        output file /data/log/access.log {
            roll_size 1gb
            roll_keep 3
            roll_keep_for 720h
        }
    }

    # Serve robots.txt
    handle_path /robots.txt {
        file_server {
            root /srv/sig-web/public
        }
    }

    # Serve sitemap.xml
    handle_path /sitemap.xml {
        file_server {
            root /srv/sig-web/public
        }
    }

${serviceBlocks}

    # Default fallback
    handle {
        respond "Welcome to ${DOMAIN}!"
    }
}
`;
}

async function writeCaddyfile(content: string, dryRun: boolean): Promise<void> {
  if (dryRun) {
    console.log("üìã [DRY-RUN] Would generate:\n");
    console.log("‚îÄ".repeat(60));
    console.log(content);
    console.log("‚îÄ".repeat(60));
    return;
  }

  // Write to temp file first
  await Bun.write(TEMP_FILE, content);

  // Use cat | tee to preserve inode (required for Docker bind mounts)
  await $`cat ${TEMP_FILE} | sudo tee ${CADDYFILE_PATH} > /dev/null`;
  await $`rm ${TEMP_FILE}`;

  console.log("‚úÖ Caddyfile written");
}

async function reloadCaddy(dryRun: boolean): Promise<void> {
  if (dryRun) {
    console.log("üìã [DRY-RUN] Would reload Caddy");
    return;
  }

  console.log("üîÑ Formatting and reloading Caddy...");

  try {
    await $`sudo docker exec -w /etc/caddy caddy caddy fmt --overwrite Caddyfile`.quiet();
    await $`sudo docker exec caddy caddy reload --config /etc/caddy/Caddyfile --adapter caddyfile --force`.quiet();
    console.log("‚úÖ Caddy reloaded");
  } catch (error) {
    console.error("‚ùå Caddy reload failed. Check logs with: sudo docker logs caddy --tail 20");
    process.exit(1);
  }
}

async function listServices(services: Services): Promise<void> {
  console.log("\nCurrent services:");
  console.log("‚îÄ".repeat(50));
  console.log(`${"SERVICE".padEnd(20)} ${"PORT".padEnd(8)} STATUS`);
  console.log("‚îÄ".repeat(50));

  for (const [name, config] of Object.entries(services).sort(([a], [b]) => a.localeCompare(b))) {
    const status = config.live ? "üü¢ live" : "üöß maint";
    console.log(`${name.padEnd(20)} ${String(config.port).padEnd(8)} ${status}`);
  }
  console.log("‚îÄ".repeat(50));
  console.log(`Total: ${Object.keys(services).length} services\n`);
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const dryRun = args.includes("--dry-run");
  const filteredArgs = args.filter((a) => a !== "--dry-run");
  const command = filteredArgs[0];

  const services = await loadServices();

  switch (command) {
    case "list": {
      await listServices(services);
      return;
    }

    case "maint": {
      const serviceName = filteredArgs[1];
      if (!serviceName) {
        console.error("Usage: bun generate.ts maint <service>");
        process.exit(1);
      }
      if (!services[serviceName]) {
        console.error(`‚ùå Service '${serviceName}' not found`);
        process.exit(1);
      }

      // Toggle state in services-state.json only
      const state = await loadServicesState();
      const currentLive = state[serviceName]?.live ?? true;
      state[serviceName] = { live: !currentLive };
      const newState = state[serviceName].live ? "üü¢ LIVE" : "üöß MAINTENANCE";
      console.log(`Toggling ${serviceName} ‚Üí ${newState}`);

      if (!dryRun) {
        await saveServicesState(state);
      }
      break;
    }

    case "add": {
      const serviceName = filteredArgs[1];
      const port = parseInt(filteredArgs[2], 10);

      if (!serviceName || !port) {
        console.error("Usage: bun generate.ts add <service> <port>");
        process.exit(1);
      }
      if (services[serviceName]) {
        console.error(`‚ùå Service '${serviceName}' already exists`);
        process.exit(1);
      }
      if (Object.values(services).some((s) => s.port === port)) {
        console.error(`‚ùå Port ${port} already in use`);
        process.exit(1);
      }

      // Add to structure file only (state defaults to live: true)
      const structure = await loadServicesStructure();
      structure[serviceName] = { port };
      console.log(`Adding ${serviceName} on port ${port}`);

      if (!dryRun) {
        await saveServicesStructure(structure);
      }
      break;
    }

    case "remove": {
      const serviceName = filteredArgs[1];
      if (!serviceName) {
        console.error("Usage: bun generate.ts remove <service>");
        process.exit(1);
      }
      if (!services[serviceName]) {
        console.error(`‚ùå Service '${serviceName}' not found`);
        process.exit(1);
      }

      // Remove from structure file
      const structure = await loadServicesStructure();
      delete structure[serviceName];
      console.log(`Removing ${serviceName}`);

      if (!dryRun) {
        await saveServicesStructure(structure);

        // Also clean up state file if it exists
        const state = await loadServicesState();
        if (state[serviceName]) {
          delete state[serviceName];
          await saveServicesState(state);
        }
      }
      break;
    }

    case undefined:
    case "generate": {
      // Default: just generate
      break;
    }

    default: {
      console.error(`Unknown command: ${command}`);
      console.error("Commands: list, maint, add, remove, generate (default)");
      process.exit(1);
    }
  }

  const caddyfile = generateCaddyfile(services);
  await writeCaddyfile(caddyfile, dryRun);

  if (!dryRun) {
    await reloadCaddy(dryRun);
  }
}

main();
